// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id           Int           @id @default(autoincrement())
  email        String        @unique @db.VarChar(255)
  password     String        @db.VarChar(255)
  isVerified   Boolean       @default(false)
  role         Role?         @default(USER)
  providerId   String?
  providerType ProviderType?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  carts   Cart[]
  store   Store?
  profile Profile?
  token   Token[]

  // invoices Invoice[]
  // addresses Address[]
  // payments Payment[]

  @@map("users")
}

enum ProviderType {
  GOOGLE
  GITHUB
  FACEBOOK
  TWITTER
}

model Profile {
  id             Int       @id @default(autoincrement())
  fullName       String    @db.VarChar(255)
  username       String    @unique @db.VarChar(125)
  profilePicture String?
  bio            String?
  phone          String?   @db.VarChar(30)
  gender         Gender?
  birthDate      DateTime?

  userId Int  @unique
  user   User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("profiles")
}

model Token {
  id    Int       @id @default(autoincrement())
  token String    @unique
  type  TokenType

  userId Int
  user   User @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  expiresAt DateTime?

  codes Code[]

  @@map("tokens")
}

model Code {
  id        Int      @id @default(autoincrement())
  code      String   @unique @db.VarChar(50)
  token     Token    @relation(fields: [tokenId], references: [id], onDelete: Cascade)
  tokenId   Int
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("codes")
}

enum TokenType {
  ACCESS_TOKEN
  VERIFY_TOKEN
  RESET_TOKEN
}

enum Gender {
  MALE
  FEMALE
}

enum Role {
  ADMIN
  USER
}

model Cart {
  qty Int

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  userId           Int
  user             User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  productVariantId Int
  productVariant   Variant @relation(fields: [productVariantId], references: [id], onDelete: Cascade)

  @@id([userId, productVariantId])
  @@map("carts")
}

model Invoice {
  id                   Int      @id @default(autoincrement())
  prices               Decimal  @db.Decimal(10, 2)
  serviceCharge        Decimal? @db.Decimal(10, 2)
  status               String
  receiverContactName  String
  receiverContactPhone String
  receiverName         String
  receiverAddressPhone String
  receiverAddress      String
  receiverPostalCode   String
  receiverCity         String
  receiverDistrict     String
  receiverProvince     String
  receiverLatitude     String   @db.VarChar(20)
  receiverLongitude    String   @db.VarChar(20)
  invoiceNumber        String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  paymentId Int?     @unique
  payment   Payment? @relation(fields: [paymentId], references: [id])
  courierId Int?     @unique
  courier   Courier? @relation(fields: [courierId], references: [id])
  orderId   Int      @unique
  order     Order    @relation(fields: [orderId], references: [id])

  invoiceHistories     InvoiceHistory[]
  confirmationPayments ConfirmationPayment[]

  @@map("invoices")
}

model Payment {
  id                    Int     @id @default(autoincrement())
  midtransTransactionId String
  midtransOrderId       String
  bank                  String
  paymentType           String
  status                String
  amount                Decimal @db.Decimal(10, 2)
  currency              String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  Invoice Invoice?

  @@map("payments")
}

model InvoiceHistory {
  id     Int    @id @default(autoincrement())
  status String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  invoiceId Int
  invoice   Invoice @relation(fields: [invoiceId], references: [id])

  @@map("invoice_histories")
}

model ConfirmationPayment {
  id     Int     @id @default(autoincrement())
  amount Decimal @db.Decimal(10, 2)
  bank   String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  invoiceId Int
  invoice   Invoice @relation(fields: [invoiceId], references: [id])

  @@map("confirmation_payments")
}

model Courier {
  id                 Int     @id @default(autoincrement())
  courierCode        String  @db.VarChar(30)
  courierServiceCode String  @db.VarChar(30)
  courierServiceName String  @db.VarChar(50)
  biteshipOrderId    String  @db.VarChar(150)
  biteshipTrackingId String  @db.VarChar(150)
  biteshipWaybillId  String? @db.VarChar(150)
  price              Decimal @db.Decimal(10, 2)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  invoice Order?   @relation(fields: [orderId], references: [id])
  Invoice Invoice?
  orderId Int?

  @@map("couriers")
}

model Store {
  id               Int     @id @default(autoincrement())
  name             String  @db.VarChar(125)
  slogan           String  @db.VarChar(125)
  description      String  @db.Text
  domain           String  @db.VarChar(125)
  logoAttachment   String?
  bannerAttachment String?

  updatedAt DateTime @updatedAt
  createdAt DateTime @default(now())

  user             User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId           Int               @unique
  bankAccounts     BankAccount[]
  messageTemplates MessageTemplate[]
  products         Product[]
  addresses        Address[]
  courierServices  CourierService[]
  orders           Order[]

  @@map("stores")
}

model CourierService {
  id                 Int    @id @default(autoincrement())
  courierCode        String @db.VarChar(30)
  courierServiceCode String @db.VarChar(30)
  courierServiceName String @db.VarChar(50)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  store   Store @relation(fields: [storeId], references: [id])
  storeId Int
}

model MessageTemplate {
  id      Int    @id @default(autoincrement())
  name    String @db.VarChar(125)
  content String @db.Text
  storeId Int
  store   Store  @relation(fields: [storeId], references: [id], onDelete: Cascade)

  updatedAt DateTime @updatedAt
  createdAt DateTime @default(now())

  @@map("message_templates")
}

model BankAccount {
  id        Int    @id @default(autoincrement())
  bank      String
  accNumber String
  accName   String

  updatedAt DateTime @updatedAt
  createdAt DateTime @default(now())

  storeId Int
  store   Store @relation(fields: [storeId], references: [id], onDelete: Cascade)

  @@map("bank_accounts")
}

model Product {
  id           Int      @id @default(autoincrement())
  name         String   @db.VarChar(125)
  description  String?  @db.Text
  attachments  String[]
  isActive     Boolean  @default(false)
  minimumOrder Int

  updatedAt DateTime @updatedAt
  createdAt DateTime @default(now())

  storeId    Int
  store      Store      @relation(fields: [storeId], references: [id], onDelete: Cascade)
  categories Category[]
  variants   Variant[]

  @@map("products")
}

model Category {
  id   Int    @id @default(autoincrement())
  name String @unique @db.VarChar(125)

  products Product[]

  parentCategoryId Int?
  parentCategory   Category?  @relation("Category", fields: [parentCategoryId], references: [id])
  subCategories    Category[] @relation("Category")

  @@map("categories")
}

// VARIANT THAT ARE AVAILABLE FOR SALE ARE VARIANT THAT DOES NOT HAVE SUBS-VARIANTS 
// Variant that have parentId null is a root variant  
model Variant {
  id           Int      @id @default(autoincrement())
  name         String   @db.VarChar(125)
  isActive     Boolean  @default(false)
  discount     Decimal? @db.Decimal(2, 1)
  sku          String?
  weightInGram Int?
  stock        Int?
  price        Decimal? @db.Decimal(10, 2)
  parentId     Int?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  productId     Int
  product       Product       @relation(fields: [productId], references: [id], onDelete: Cascade)
  parentVariant Variant?      @relation("Variant", fields: [parentId], references: [id], onDelete: Cascade)
  subVariants   Variant[]     @relation("Variant")
  orderDetails  OrderDetail[]
  carts         Cart[]

  @@unique([name, productId])
  @@map("product_variants")
}

// model Variant {
//   id Int @id @default(autoincrement())

//   product   Product @relation(fields: [productId], references: [id])
//   productId Int

//   Cart                Cart[]
//   OrderDetail         OrderDetail[]
// }

// model VariantValue {
//  variantId 
//  variant Variant
// }

// model OptionValue {

// }

// model Option {

// }

// model ProductOption {

// }

model Address {
  id             Int     @id @default(autoincrement())
  name           String
  address        String
  postalCode     String  @db.VarChar(50)
  city           String
  district       String
  province       String
  latitude       String  @db.VarChar(20)
  longitude      String  @db.VarChar(20)
  isMainLocation Boolean

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  storeId Int
  store   Store @relation(fields: [storeId], references: [id], onDelete: Cascade)
}

model OrderHistory {
  id      Int    @id @default(autoincrement())
  content String @db.Text
  order   Order  @relation(fields: [orderId], references: [id], onDelete: Cascade)
  orderId Int

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model OrderDetail {
  qty                    Int
  pricePerProduct        Decimal @db.Decimal(10, 2)
  weightPerProductInGram Int
  orderId                Int
  order                  Order   @relation(fields: [orderId], references: [id])
  productVariantId       Int
  productVariant         Variant @relation(fields: [productVariantId], references: [id])

  @@id([productVariantId, orderId])
}

model Order {
  id          Int         @id @default(autoincrement())
  status      OrderStatus @default(NOT_PAID)
  description String?     @db.Text

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  storeId   Int?
  store     Store?         @relation(fields: [storeId], references: [id])
  histories OrderHistory[]
  products  OrderDetail[]
  invoice   Invoice?
  Courier   Courier[]

  @@map("orders")
}

enum OrderStatus {
  NOT_PAID
  NEW_ORDER
  READY_TO_DELIVER
  ON_DELIVERY
  SUCCESS
  CANCELLED
}

// model Decoration {
//   id   Int    @id @default(autoincrement())
//   type String

//   updatedAt DateTime @updatedAt
//   createdAt DateTime @default(now())

//   storeOnDecorations StoreOnDecoration[]

//   @@map("decorations")
// }

// model Transaction {
//   id                    Int      @id @default(autoincrement())
//   midtransTransactionId Int
//   paymentType           String
//   status                String
//   amount                Int
//   currency              String
//   createdAt             DateTime @default(now())
//   updatedAt             DateTime @updatedAt
//   // Timestamp of the transaction
// }

// model StoreOnDecoration {
//   id Int @id @default(autoincrement())

//   createdAt DateTime @default(now())
//   updatedAt DateTime @updatedAt

//   decorationId Int
//   decoration   Decoration @relation(fields: [decorationId], references: [id])
//   storeId      Int
//   store        Store      @relation(fields: [storeId], references: [id])

//   @@map("store_on_decorations")
// }
